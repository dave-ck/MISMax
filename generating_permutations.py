import numpy as np
from numba import njit


# generated by ChatGPT from wikipedia's Heap's alg. pseudocode, then modified here
# @njit
def generate_permutations(n):
    assert n < 256, "n too large - n can't fit in a uint8, and n! permutations can't fit in the universe"
    A = np.arange(n, dtype=np.uint8)
    # c is an encoding of the stack state. c[k] encodes the for-loop counter for when generate(k - 1, A) is called
    c = np.zeros(n, dtype=np.uint8)
    out_arr = np.empty((np.math.factorial(n), n), dtype=np.uint8)

    out_arr[0] = A

    # i acts similarly to a stack pointer
    i = 1
    index = 1
    while i < n:
        if c[i] < i:
            if i % 2 == 0:
                A[0], A[i] = A[i], A[0]
            else:
                A[c[i]], A[i] = A[i], A[c[i]]
            out_arr[index] = A
            index += 1
            # Swap has occurred, ending the for-loop. Simulate the increment of the for-loop counter
            c[i] += 1
            # Simulate recursive call reaching the base case by bringing the pointer to the base case analog in the array
            i = 1
        else:
            # Calling generate(i+1, A) has ended as the for-loop terminated. Reset the state and simulate popping the stack by incrementing the pointer.
            c[i] = 0
            i += 1
    return out_arr



@njit
def perm_generator(n):
    assert n < 256, "n too large - n can't fit in a uint8, and n! permutations can't fit in the universe"
    A = np.arange(n, dtype=np.uint8)
    # c is an encoding of the stack state. c[k] encodes the for-loop counter for when generate(k - 1, A) is called
    c = np.zeros(n, dtype=np.uint8)
    yield A
    # i acts similarly to a stack pointer
    i = 1
    while i < n:
        if c[i] < i:
            if i % 2 == 0:
                A[0], A[i] = A[i], A[0]
            else:
                A[c[i]], A[i] = A[i], A[c[i]]
            yield A
            # Swap has occurred, ending the for-loop. Simulate the increment of the for-loop counter
            c[i] += 1
            # Simulate recursive call reaching the base case by bringing the pointer to the base case analog in the array
            i = 1
        else:
            # Calling generate(i+1, A) has ended as the for-loop terminated. Reset the state and simulate popping the stack by incrementing the pointer.
            c[i] = 0
            i += 1


def permutations(n):
    a = np.zeros((np.math.factorial(n), n), np.uint8)
    f = 1
    for m in range(2, n + 1):
        b = a[:f, n - m + 1:]  # the block of permutations of range(m-1)
        for i in range(1, m):
            a[i * f:(i + 1) * f, n - m] = i
            a[i * f:(i + 1) * f, n - m + 1:] = b + (b >= i)
        b += 1
        f *= m
    return a


n = 6
heaps_perms = generate_permutations(n)
my_perms = permutations(n)

for A in perm_generator(4):
    print(A)
